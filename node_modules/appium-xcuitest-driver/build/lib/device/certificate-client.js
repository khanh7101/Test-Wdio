"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CertificateClient = void 0;
const py_ios_device_client_1 = require("./clients/py-ios-device-client");
const remotexpc_utils_1 = require("./remotexpc-utils");
/**
 * Unified Certificate Client
 *
 * Provides a unified interface for certificate operations on iOS devices,
 * automatically handling the differences between iOS < 18 (py-ios-device)
 * and iOS 18 and above (appium-ios-remotexpc MobileConfigService).
 */
class CertificateClient {
    service;
    remoteXPCConnection;
    log;
    constructor(service, log, remoteXPCConnection) {
        this.service = service;
        this.log = log;
        this.remoteXPCConnection = remoteXPCConnection;
    }
    //#region Public Methods
    /**
     * Create a certificate client for device
     *
     * @param udid - Device UDID
     * @param log - Appium logger instance
     * @param useRemoteXPC - Whether to use remotexpc (use isIos18OrNewer(opts) to determine)
     * @returns Certificate client instance
     */
    static async create(udid, log, useRemoteXPC) {
        if (useRemoteXPC) {
            const client = await CertificateClient.withRemoteXpcConnection(async () => {
                const Services = await (0, remotexpc_utils_1.getRemoteXPCServices)();
                const { mobileConfigService, remoteXPC } = await Services.startMobileConfigService(udid);
                return {
                    service: mobileConfigService,
                    connection: remoteXPC,
                };
            }, log);
            if (client) {
                return client;
            }
        }
        // Fallback to py-ios-device
        const pyideviceClient = new py_ios_device_client_1.Pyidevice({
            udid,
            log,
        });
        await pyideviceClient.assertExists(true);
        return new CertificateClient(pyideviceClient, log);
    }
    /**
     * Install a certificate profile
     *
     * @param options - Installation options containing the certificate payload
     */
    async installCertificate(options) {
        const { payload } = options;
        if (this.isRemoteXPC) {
            await this.mobileConfigService.installProfileFromBuffer(payload);
        }
        else {
            await this.pyideviceClient.installProfile({ payload });
        }
    }
    /**
     * Remove a certificate profile by name
     *
     * @param name - Name of the profile to remove
     * @returns Status message ('Acknowledged' for RemoteXPC, or pyidevice output)
     */
    async removeCertificate(name) {
        if (this.isRemoteXPC) {
            await this.mobileConfigService.removeProfile(name);
            return 'Acknowledged';
        }
        else {
            return await this.pyideviceClient.removeProfile(name);
        }
    }
    /**
     * List installed certificate profiles
     *
     * @returns List of installed certificates
     */
    async listCertificates() {
        if (this.isRemoteXPC) {
            return await this.mobileConfigService.getProfileList();
        }
        else {
            return await this.pyideviceClient.listProfiles();
        }
    }
    /**
     * Close the certificate service connection and remoteXPC connection if present
     */
    async close() {
        if (this.remoteXPCConnection) {
            try {
                this.log.debug(`Closing remoteXPC connection`);
                await this.remoteXPCConnection.close();
            }
            catch (err) {
                this.log.debug(`Error closing remoteXPC connection: ${err.message}`);
            }
        }
    }
    //#endregion
    //#region Private Methods
    /**
     * Check if this client is using RemoteXPC
     */
    get isRemoteXPC() {
        return !!this.remoteXPCConnection;
    }
    /**
     * Helper to safely execute remoteXPC operations with connection cleanup
     * @param operation - Async operation that returns service and connection
     * @param log - Logger instance
     * @returns CertificateClient on success, null on failure
     */
    static async withRemoteXpcConnection(operation, log) {
        let remoteXPCConnection;
        let succeeded = false;
        try {
            const { service, connection } = await operation();
            remoteXPCConnection = connection;
            const client = new CertificateClient(service, log, remoteXPCConnection);
            succeeded = true;
            return client;
        }
        catch (err) {
            log.error(`Failed to create certificate client via RemoteXPC: ${err.message}, falling back to py-ios-device`);
            return null;
        }
        finally {
            // Only close connection if we failed (if succeeded, the client owns it)
            if (remoteXPCConnection && !succeeded) {
                try {
                    await remoteXPCConnection.close();
                }
                catch {
                    // Ignore cleanup errors
                }
            }
        }
    }
    /**
     * Get service as RemoteXPC MobileConfigService
     */
    get mobileConfigService() {
        return this.service;
    }
    /**
     * Get service as Pyidevice client
     */
    get pyideviceClient() {
        return this.service;
    }
}
exports.CertificateClient = CertificateClient;
//# sourceMappingURL=certificate-client.js.map