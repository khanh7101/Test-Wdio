"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AfcClient = void 0;
const stream_1 = require("stream");
const promises_1 = require("stream/promises");
const path_1 = __importDefault(require("path"));
const lodash_1 = __importDefault(require("lodash"));
const bluebird_1 = __importDefault(require("bluebird"));
const support_1 = require("appium/support");
const appium_ios_device_1 = require("appium-ios-device");
const remotexpc_utils_1 = require("./remotexpc-utils");
const logger_1 = require("../logger");
const real_device_management_1 = require("./real-device-management");
/**
 * Unified AFC Client
 *
 * Provides a unified interface for file operations on iOS devices,
 * automatically handling the differences between iOS < 18 (appium-ios-device)
 * and iOS 18 and above (appium-ios-remotexpc).
 */
class AfcClient {
    service;
    remoteXPCConnection;
    constructor(service, remoteXPCConnection) {
        this.service = service;
        this.remoteXPCConnection = remoteXPCConnection;
    }
    //#region Public Methods
    /**
     * Create an AFC client for device
     *
     * @param udid - Device UDID
     * @param useRemoteXPC - Whether to use remotexpc (use isIos18OrNewer(opts) to determine)
     * @returns AFC client instance
     */
    static async createForDevice(udid, useRemoteXPC) {
        if (useRemoteXPC) {
            const client = await AfcClient.withRemoteXpcConnection(async () => {
                const Services = await (0, remotexpc_utils_1.getRemoteXPCServices)();
                const connectionResult = await Services.createRemoteXPCConnection(udid);
                const afcService = await Services.startAfcService(udid);
                return {
                    service: afcService,
                    connection: connectionResult.remoteXPC,
                };
            });
            if (client) {
                return client;
            }
        }
        const afcService = await appium_ios_device_1.services.startAfcService(udid);
        return new AfcClient(afcService);
    }
    /**
     * Create an AFC client for app container access
     *
     * @param udid - Device UDID
     * @param bundleId - App bundle identifier
     * @param useRemoteXPC - Whether to use remotexpc (use isIos18OrNewer(opts) to determine)
     * @param options - Optional configuration for container access
     * @returns AFC client instance
     */
    static async createForApp(udid, bundleId, useRemoteXPC, options) {
        const { containerType = null, skipDocumentsCheck = false } = options ?? {};
        const isDocuments = !skipDocumentsCheck && containerType?.toLowerCase() === 'documents';
        if (useRemoteXPC) {
            const client = await AfcClient.withRemoteXpcConnection(async () => {
                const Services = await (0, remotexpc_utils_1.getRemoteXPCServices)();
                const connectionResult = await Services.createRemoteXPCConnection(udid);
                const { houseArrestService, remoteXPC: houseArrestRemoteXPC } = await Services.startHouseArrestService(udid);
                const afcService = isDocuments
                    ? await houseArrestService.vendDocuments(bundleId)
                    : await houseArrestService.vendContainer(bundleId);
                // Use the remoteXPC from house arrest service if available, otherwise use the one from connection
                const connection = houseArrestRemoteXPC ?? connectionResult.remoteXPC;
                return {
                    service: afcService,
                    connection,
                };
            });
            if (client) {
                return client;
            }
        }
        const houseArrestService = await appium_ios_device_1.services.startHouseArrestService(udid);
        const afcService = isDocuments
            ? await houseArrestService.vendDocuments(bundleId)
            : await houseArrestService.vendContainer(bundleId);
        return new AfcClient(afcService);
    }
    /**
     * Check if a path is a directory
     */
    async isDirectory(path) {
        if (this.isRemoteXPC) {
            return await this.remoteXPCAfcService.isdir(path);
        }
        const fileInfo = await this.iosDeviceAfcService.getFileInfo(path);
        return fileInfo.isDirectory();
    }
    /**
     * List directory contents
     */
    async listDirectory(path) {
        if (this.isRemoteXPC) {
            return await this.remoteXPCAfcService.listdir(path);
        }
        return await this.iosDeviceAfcService.listDirectory(path);
    }
    /**
     * Create a directory
     */
    async createDirectory(path) {
        if (this.isRemoteXPC) {
            await this.remoteXPCAfcService.mkdir(path);
        }
        else {
            await this.iosDeviceAfcService.createDirectory(path);
        }
    }
    /**
     * Delete a directory or file
     */
    async deleteDirectory(path) {
        if (this.isRemoteXPC) {
            await this.remoteXPCAfcService.rm(path, true);
        }
        else {
            await this.iosDeviceAfcService.deleteDirectory(path);
        }
    }
    /**
     * Get file contents as a buffer
     */
    async getFileContents(path) {
        if (this.isRemoteXPC) {
            return await this.remoteXPCAfcService.getFileContents(path);
        }
        // For ios-device, use stream-based approach
        const stream = await this.iosDeviceAfcService.createReadStream(path, {
            autoDestroy: true,
        });
        const buffers = [];
        return new Promise((resolve, reject) => {
            stream.on('data', (data) => buffers.push(data));
            stream.on('end', () => resolve(Buffer.concat(buffers)));
            stream.on('error', reject);
        });
    }
    /**
     * Set file contents from a buffer
     */
    async setFileContents(path, data) {
        if (this.isRemoteXPC) {
            await this.remoteXPCAfcService.setFileContents(path, data);
            return;
        }
        // For ios-device, convert buffer to stream and use writeFromStream
        const bufferStream = stream_1.Readable.from([data]);
        return await this.writeFromStream(path, bufferStream);
    }
    /**
     * Write file contents from a readable stream
     */
    async writeFromStream(path, stream) {
        if (this.isRemoteXPC) {
            await this.remoteXPCAfcService.writeFromStream(path, stream);
            return;
        }
        const writeStream = await this.iosDeviceAfcService.createWriteStream(path, {
            autoDestroy: true,
        });
        writeStream.on('finish', () => {
            if (typeof writeStream.destroy === 'function') {
                writeStream.destroy();
            }
        });
        return new Promise((resolve, reject) => {
            writeStream.on('close', resolve);
            const onError = (e) => {
                stream.unpipe(writeStream);
                reject(e);
            };
            writeStream.on('error', onError);
            stream.on('error', onError);
            stream.pipe(writeStream);
        });
    }
    /**
     * Pull files/folders from device to local filesystem.
     * Uses the appropriate mechanism (walkDir for ios-device, pull for remotexpc).
     *
     * @param remotePath - Remote path on the device (file or directory)
     * @param localPath - Local destination path
     * @param options - Pull options (recursive, overwrite, onEntry)
     */
    async pull(remotePath, localPath, options = {}) {
        if (this.isRemoteXPC) {
            // RemoteXPC expects 'callback' property, so map onEntry -> callback
            const remoteXpcOptions = {
                ...options,
                callback: options.onEntry,
            };
            delete remoteXpcOptions.onEntry;
            await this.remoteXPCAfcService.pull(remotePath, localPath, remoteXpcOptions);
        }
        else {
            await this.pullWithWalkDir(remotePath, localPath, options);
        }
    }
    /**
     * Close the AFC service connection and remoteXPC connection if present
     */
    async close() {
        this.service.close();
        if (this.remoteXPCConnection) {
            try {
                await this.remoteXPCConnection.close();
            }
            catch { }
        }
    }
    //#endregion
    //#region Private Methods
    /**
     * Check if this client is using RemoteXPC
     */
    get isRemoteXPC() {
        return !!this.remoteXPCConnection;
    }
    /**
     * Helper to safely execute remoteXPC operations with connection cleanup
     * @param operation - Async operation that returns an AfcClient
     * @returns AfcClient on success, null on failure
     */
    static async withRemoteXpcConnection(operation) {
        let remoteXPCConnection;
        let succeeded = false;
        try {
            const { service, connection } = await operation();
            remoteXPCConnection = connection;
            const client = new AfcClient(service, remoteXPCConnection);
            succeeded = true;
            return client;
        }
        catch (err) {
            logger_1.log.error(`Failed to create AFC client via RemoteXPC: ${err.message}, falling back to appium-ios-device`);
            return null;
        }
        finally {
            // Only close connection if we failed (if succeeded, the client owns it)
            if (remoteXPCConnection && !succeeded) {
                try {
                    await remoteXPCConnection.close();
                }
                catch {
                    // Ignore cleanup errors
                }
            }
        }
    }
    /**
     * Get service as RemoteXPC AFC service
     */
    get remoteXPCAfcService() {
        return this.service;
    }
    /**
     * Get service as iOS Device AFC service
     */
    get iosDeviceAfcService() {
        return this.service;
    }
    /**
     * Create a read stream for a file (internal use only).
     */
    async createReadStream(remotePath, options) {
        if (this.isRemoteXPC) {
            // Use readToStream which returns a streaming Readable
            return await this.remoteXPCAfcService.readToStream(remotePath);
        }
        return await this.iosDeviceAfcService.createReadStream(remotePath, options);
    }
    /**
     * Internal implementation of pull for ios-device using walkDir.
     * Walks the remote directory tree and pulls files to local filesystem.
     */
    async pullWithWalkDir(remotePath, localPath, options) {
        const { recursive = false, overwrite = true, onEntry } = options;
        const isDir = await this.isDirectory(remotePath);
        if (!isDir) {
            // Single file pull
            const localFilePath = (await this.isLocalDirectory(localPath))
                ? path_1.default.join(localPath, path_1.default.posix.basename(remotePath))
                : localPath;
            await this.checkOverwrite(localFilePath, overwrite);
            await this.pullSingleFile(remotePath, localFilePath);
            if (onEntry) {
                await onEntry(remotePath, localFilePath, false);
            }
            return;
        }
        // Directory pull requires recursive option
        if (!recursive) {
            throw new Error(`Cannot pull directory '${remotePath}' without recursive option. Set recursive: true to pull directories.`);
        }
        // Determine local root directory
        const localDstIsDirectory = await this.isLocalDirectory(localPath);
        const localRootDir = localDstIsDirectory
            ? path_1.default.join(localPath, path_1.default.posix.basename(remotePath))
            : localPath;
        // Create the root directory
        await (0, support_1.mkdirp)(localRootDir);
        if (onEntry) {
            await onEntry(remotePath, localRootDir, true);
        }
        const pullPromises = [];
        // Walk the remote directory and pull files in parallel
        await this.iosDeviceAfcService.walkDir(remotePath, true, async (entryPath, isDirectory) => {
            // Calculate relative path from remote root
            const relativePath = entryPath.startsWith(remotePath + '/')
                ? entryPath.slice(remotePath.length + 1)
                : entryPath.slice(remotePath.length);
            const localEntryPath = path_1.default.join(localRootDir, relativePath);
            if (isDirectory) {
                await (0, support_1.mkdirp)(localEntryPath);
                if (onEntry) {
                    await onEntry(entryPath, localEntryPath, true);
                }
            }
            else {
                await this.checkOverwrite(localEntryPath, overwrite);
                // Ensure parent directory exists
                const parentDir = path_1.default.dirname(localEntryPath);
                await (0, support_1.mkdirp)(parentDir);
                // Start async file pull (non-blocking)
                const readStream = await this.iosDeviceAfcService.createReadStream(entryPath, {
                    autoDestroy: true,
                });
                const writeStream = support_1.fs.createWriteStream(localEntryPath, { autoClose: true });
                pullPromises.push(new bluebird_1.default((resolve) => {
                    writeStream.on('close', async () => {
                        // Invoke onEntry callback after successful pull
                        if (onEntry) {
                            try {
                                await onEntry(entryPath, localEntryPath, false);
                            }
                            catch (err) {
                                logger_1.log.warn(`onEntry callback failed for '${entryPath}': ${err.message}`);
                            }
                        }
                        resolve();
                    });
                    const onStreamingError = (e) => {
                        readStream.unpipe(writeStream);
                        logger_1.log.warn(`Cannot pull '${entryPath}' to '${localEntryPath}'. ` +
                            `The file will be skipped. Original error: ${e.message}`);
                        resolve();
                    };
                    writeStream.on('error', onStreamingError);
                    readStream.on('error', onStreamingError);
                }).timeout(real_device_management_1.IO_TIMEOUT_MS));
                readStream.pipe(writeStream);
                if (pullPromises.length >= real_device_management_1.MAX_IO_CHUNK_SIZE) {
                    await bluebird_1.default.any(pullPromises);
                    for (let i = pullPromises.length - 1; i >= 0; i--) {
                        if (pullPromises[i].isFulfilled()) {
                            pullPromises.splice(i, 1);
                        }
                    }
                }
            }
        });
        // Wait for remaining files to be pulled
        if (!lodash_1.default.isEmpty(pullPromises)) {
            await bluebird_1.default.all(pullPromises);
        }
    }
    /**
     * Check if local file exists and should not be overwritten.
     * Throws an error if the file exists and overwrite is false.
     *
     * @param localPath - Local file path to check
     * @param overwrite - Whether to allow overwriting existing files
     */
    async checkOverwrite(localPath, overwrite) {
        if (!overwrite && await support_1.fs.exists(localPath)) {
            throw new Error(`Local file already exists: ${localPath}`);
        }
    }
    /**
     * Pull a single file from device to local filesystem using streams.
     * This method only works for ios-device.
     *
     * @param remotePath - Remote file path
     * @param localPath - Local destination path
     */
    async pullSingleFile(remotePath, localPath) {
        const readStream = await this.iosDeviceAfcService.createReadStream(remotePath, {
            autoDestroy: true,
        });
        const writeStream = support_1.fs.createWriteStream(localPath, { autoClose: true });
        await (0, promises_1.pipeline)(readStream, writeStream);
    }
    /**
     * Check if a local path exists and is a directory.
     */
    async isLocalDirectory(localPath) {
        try {
            const stats = await support_1.fs.stat(localPath);
            return stats.isDirectory();
        }
        catch {
            return false;
        }
    }
}
exports.AfcClient = AfcClient;
//# sourceMappingURL=afc-client.js.map