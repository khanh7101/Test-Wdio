"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.elementDisplayed = elementDisplayed;
exports.elementEnabled = elementEnabled;
exports.elementSelected = elementSelected;
exports.getName = getName;
exports.getNativeAttribute = getNativeAttribute;
exports.getAttribute = getAttribute;
exports.getProperty = getProperty;
exports.getText = getText;
exports.getElementRect = getElementRect;
exports.getLocation = getLocation;
exports.getLocationInView = getLocationInView;
exports.getSize = getSize;
exports.setValueImmediate = setValueImmediate;
exports.setValue = setValue;
exports.setValueWithWebAtom = setValueWithWebAtom;
exports.keys = keys;
exports.clear = clear;
exports.getContentSize = getContentSize;
exports.getNativeRect = getNativeRect;
const lodash_1 = __importDefault(require("lodash"));
const driver_1 = require("appium/driver");
const support_1 = require("appium/support");
/**
 * Checks whether an element is displayed.
 *
 * @param el - Element or element ID
 */
async function elementDisplayed(el) {
    const elementId = support_1.util.unwrapElement(el);
    if (this.isWebContext()) {
        const atomsElement = this.getAtomsElement(elementId);
        return await this.executeAtom('is_displayed', [atomsElement]);
    }
    return await this.proxyCommand(`/element/${elementId}/displayed`, 'GET');
}
/**
 * Checks whether an element is enabled.
 *
 * @param el - Element or element ID
 */
async function elementEnabled(el) {
    const elementId = support_1.util.unwrapElement(el);
    if (this.isWebContext()) {
        const atomsElement = this.getAtomsElement(elementId);
        return await this.executeAtom('is_enabled', [atomsElement]);
    }
    return await this.proxyCommand(`/element/${elementId}/enabled`, 'GET');
}
/**
 * Checks whether an element is selected.
 *
 * @param el - Element or element ID
 */
async function elementSelected(el) {
    const elementId = support_1.util.unwrapElement(el);
    if (this.isWebContext()) {
        const atomsElement = this.getAtomsElement(elementId);
        return await this.executeAtom('is_selected', [atomsElement]);
    }
    return await this.proxyCommand(`/element/${elementId}/selected`, 'GET');
}
/**
 * Gets the tag/name of an element.
 *
 * @param el - Element or element ID
 */
async function getName(el) {
    const elementId = support_1.util.unwrapElement(el);
    if (this.isWebContext()) {
        const atomsElement = this.getAtomsElement(elementId);
        const script = 'return arguments[0].tagName.toLowerCase()';
        return await this.executeAtom('execute_script', [script, [atomsElement]]);
    }
    return await this.proxyCommand(`/element/${elementId}/name`, 'GET');
}
/**
 * Gets a native attribute (non-web) from an element.
 *
 * @param attribute - Attribute name
 * @param el - Element or element ID
 */
async function getNativeAttribute(attribute, el) {
    if (attribute === 'contentSize') {
        return await this.getContentSize(el);
    }
    const elementId = support_1.util.unwrapElement(el);
    let value = await this.proxyCommand(`/element/${elementId}/attribute/${attribute}`, 'GET');
    if ([0, 1].includes(value)) {
        value = !!value;
    }
    return lodash_1.default.isNull(value) || lodash_1.default.isString(value) ? value : JSON.stringify(value);
}
/**
 * Gets an element attribute (web or native).
 *
 * @param attribute - Attribute name
 * @param el - Element or element ID
 */
async function getAttribute(attribute, el) {
    const elementId = support_1.util.unwrapElement(el);
    if (!this.isWebContext()) {
        return await this.getNativeAttribute(attribute, elementId);
    }
    const atomsElement = this.getAtomsElement(elementId);
    return await this.executeAtom('get_attribute_value', [atomsElement, attribute]);
}
/**
 * Gets an element property (web) or native attribute fallback.
 *
 * @param property - Property name
 * @param el - Element or element ID
 */
async function getProperty(property, el) {
    const elementId = support_1.util.unwrapElement(el);
    if (!this.isWebContext()) {
        return await this.getNativeAttribute(property, elementId);
    }
    const atomsElement = this.getAtomsElement(elementId);
    return await this.executeAtom('get_attribute_value', [atomsElement, property]);
}
/**
 * Gets the text content of an element.
 *
 * @param el - Element or element ID
 */
async function getText(el) {
    const elementId = support_1.util.unwrapElement(el);
    if (!this.isWebContext()) {
        return await this.proxyCommand(`/element/${elementId}/text`, 'GET');
    }
    const atomsElement = this.getAtomsElement(elementId);
    return await this.executeAtom('get_text', [atomsElement]);
}
/**
 * Gets the bounding rect of an element.
 *
 * @param el - Element or element ID
 */
async function getElementRect(el) {
    if (this.isWebContext()) {
        const { x, y } = await this.getLocation(el);
        const { width, height } = await this.getSize(el);
        return { x, y, width, height };
    }
    const elementId = support_1.util.unwrapElement(el);
    return await this.getNativeRect(elementId);
}
/**
 * Gets the top-left location of an element.
 *
 * @param elementId - Element or element ID
 */
async function getLocation(elementId) {
    const el = support_1.util.unwrapElement(elementId);
    if (this.isWebContext()) {
        const atomsElement = this.getAtomsElement(el);
        const loc = await this.executeAtom('get_top_left_coordinates', [atomsElement]);
        if (this.opts.absoluteWebLocations) {
            const script = 'return [' +
                'Math.max(window.pageXOffset,document.documentElement.scrollLeft,document.body.scrollLeft),' +
                'Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop)];';
            const [xOffset, yOffset] = await this.execute(script);
            loc.x += xOffset;
            loc.y += yOffset;
        }
        return loc;
    }
    const rect = await this.getElementRect(el);
    return { x: rect.x, y: rect.y };
}
/**
 * Alias for getLocation.
 *
 * @param elementId - Element or element ID
 */
async function getLocationInView(elementId) {
    return await this.getLocation(elementId);
}
/**
 * Gets the size of an element.
 *
 * @param el - Element or element ID
 */
async function getSize(el) {
    const elementId = support_1.util.unwrapElement(el);
    if (this.isWebContext()) {
        return await this.executeAtom('get_size', [this.getAtomsElement(elementId)]);
    }
    const rect = await this.getElementRect(elementId);
    return { width: rect.width, height: rect.height };
}
/**
 * Legacy alias for setValue; always types via keyboard.
 *
 * @param value - Value to set
 * @param el - Element or element ID
 */
async function setValueImmediate(value, el) {
    this.log.info('There is currently no way to bypass typing using XCUITest. Setting value through keyboard');
    await this.setValue(value, el);
}
/**
 * Sets an element value (native or web).
 *
 * @param value - Value to set
 * @param el - Element or element ID
 */
async function setValue(value, el) {
    const elementId = support_1.util.unwrapElement(el);
    if (!this.isWebContext()) {
        await this.proxyCommand(`/element/${elementId}/value`, 'POST', {
            value: prepareInputValue(value),
        });
        return;
    }
    const atomsElement = this.getAtomsElement(elementId);
    await this.executeAtom('click', [atomsElement]);
    if (this.opts.sendKeyStrategy !== 'oneByOne') {
        await this.setValueWithWebAtom(atomsElement, value);
        return;
    }
    for (const char of prepareInputValue(value)) {
        await this.setValueWithWebAtom(atomsElement, char);
    }
}
/**
 * Types text into a web element using atoms.
 *
 * @param atomsElement - Target atoms element
 * @param value - Text to type
 */
async function setValueWithWebAtom(atomsElement, value) {
    await this.executeAtom('type', [atomsElement, value]);
    if (this.opts.skipTriggerInputEventAfterSendkeys) {
        return;
    }
    function triggerInputEvent(input) {
        const lastValue = '';
        const event = new Event('input', { bubbles: true });
        const tracker = input._valueTracker;
        if (tracker) {
            tracker.setValue(lastValue);
        }
        input.dispatchEvent(event);
    }
    const scriptAsString = `return (${triggerInputEvent}).apply(null, arguments)`;
    await this.executeAtom('execute_script', [scriptAsString, [atomsElement]]);
}
/**
 * Sends raw key sequences via WDA.
 *
 * @param value - Keys to send
 */
async function keys(value) {
    await this.proxyCommand('/wda/keys', 'POST', {
        value: prepareInputValue(value),
    });
}
/**
 * Clears the contents of an element.
 *
 * @param el - Element or element ID
 */
async function clear(el) {
    const elementId = support_1.util.unwrapElement(el);
    if (this.isWebContext()) {
        const atomsElement = this.getAtomsElement(elementId);
        await this.executeAtom('clear', [atomsElement]);
        return;
    }
    await this.proxyCommand(`/element/${elementId}/clear`, 'POST');
}
/**
 * Gets content size for table/collection views (native only).
 *
 * @param el - Element or element ID
 */
async function getContentSize(el) {
    if (this.isWebContext()) {
        throw new driver_1.errors.NotYetImplementedError('Support for getContentSize for web context is not yet implemented. Please contact an Appium dev');
    }
    const type = await this.getAttribute('type', el);
    if (type !== 'XCUIElementTypeTable' && type !== 'XCUIElementTypeCollectionView') {
        throw new Error(`Can't get content size for type '${type}', only for tables and collection views`);
    }
    let locator = '*';
    if (type === 'XCUIElementTypeTable') {
        locator = 'XCUIElementTypeCell';
    }
    let contentHeight = 0;
    const children = await this.findElOrEls('class chain', locator, true, el);
    if (children.length === 1) {
        const rect = await this.getElementRect(children[0]);
        contentHeight = rect.height;
    }
    else if (children.length) {
        switch (type) {
            case 'XCUIElementTypeTable': {
                const firstRect = await this.getElementRect(lodash_1.default.head(children));
                const lastRect = await this.getElementRect(lodash_1.default.last(children));
                contentHeight = lastRect.y + lastRect.height - firstRect.y;
                break;
            }
            case 'XCUIElementTypeCollectionView': {
                let elsInRow = 1;
                const firstRect = await this.getElementRect(lodash_1.default.head(children));
                const initialRects = [firstRect];
                for (let i = 1; i < children.length; i++) {
                    const rect = await this.getElementRect(children[i]);
                    initialRects.push(rect);
                    if (rect.y !== firstRect.y) {
                        elsInRow = i;
                        break;
                    }
                }
                const spaceBetweenEls = initialRects[elsInRow].y -
                    initialRects[elsInRow - 1].y -
                    initialRects[elsInRow - 1].height;
                const numRows = Math.ceil(children.length / elsInRow);
                contentHeight = numRows * firstRect.height + spaceBetweenEls * (numRows - 1);
                break;
            }
            default:
                throw new Error(`Programming error: type '${type}' was not valid but should have already been rejected`);
        }
    }
    const size = await this.getSize(el);
    const origin = await this.getLocationInView(el);
    return JSON.stringify({
        width: size.width,
        height: size.height,
        top: origin.y,
        left: origin.x,
        scrollableOffset: contentHeight,
    });
}
/**
 * Gets the native rect of an element (no web fallback).
 *
 * @param el - Element or element ID
 */
async function getNativeRect(el) {
    const elementId = support_1.util.unwrapElement(el);
    return await this.proxyCommand(`/element/${elementId}/rect`, 'GET');
}
function prepareInputValue(inp) {
    if (![lodash_1.default.isArray, lodash_1.default.isString, lodash_1.default.isFinite].some((f) => f(inp))) {
        throw new Error(`Only strings, numbers and arrays are supported as input arguments. ` +
            `Received: ${JSON.stringify(inp)}`);
    }
    if (lodash_1.default.isArray(inp)) {
        inp = inp.join('');
    }
    else if (lodash_1.default.isFinite(inp)) {
        inp = `${inp}`;
    }
    return [...String(inp)].map((k) => {
        if (['\uE006', '\uE007'].includes(k)) {
            return '\n';
        }
        if (['\uE003', '\ue017'].includes(k)) {
            return '\b';
        }
        return k;
    });
}
//# sourceMappingURL=element.js.map