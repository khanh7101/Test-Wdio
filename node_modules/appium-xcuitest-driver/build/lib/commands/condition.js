"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.listConditionInducers = listConditionInducers;
exports.enableConditionInducer = enableConditionInducer;
exports.disableConditionInducer = disableConditionInducer;
const appium_ios_device_1 = require("appium-ios-device");
const lodash_1 = __importDefault(require("lodash"));
const utils_1 = require("../utils");
const remotexpc_utils_1 = require("../device/remotexpc-utils");
/**
 * Get all available ConditionInducer configuration information, which can be used with
 * {@linkcode XCUITestDriver.enableConditionInducer}
 * @since 4.9.0
 * @see {@link https://help.apple.com/xcode/mac/current/#/dev308429d42}
 */
async function listConditionInducers() {
    (0, utils_1.requireRealDevice)(this, 'Condition inducer');
    const facade = this._conditionInducer ?? await createConditionInducer(this);
    return await facade.list();
}
/**
 * Enable a "condition inducer". You can create a condition on a connected device to test your app under adverse conditions,
 * such as poor network connectivity or thermal constraints. When you start a device condition,
 * the operating system on the device behaves as if its environment has changed. The device
 * condition remains active until you stop the device condition or disconnect the device. For
 * example, you can start a device condition, run your app, monitor your app's energy usage, and
 * then stop the condition.
 *
 * (Note: the socket needs to remain connected during operation)
 * (Note: Device conditions are available only for real devices running iOS 13.0 and later.)
 *
 * @param conditionID - Determine which condition IDs are available with the {@linkcode XCUITestDriver.listConditionInducers} command
 * @param profileID - Determine which profile IDs are available with the {@linkcode XCUITestDriver.listConditionInducers} command
 * @returns `true` if enabling the condition succeeded
 * @throws {Error} If you try to start another Condition and the previous Condition has not stopped
 * @since 4.9.0
 * @see {@link https://help.apple.com/xcode/mac/current/#/dev308429d42}
 */
async function enableConditionInducer(conditionID, profileID) {
    (0, utils_1.requireRealDevice)(this, 'Condition inducer');
    if (this._conditionInducer?.isActive()) {
        throw this.log.errorWithException(`Condition inducer is already running. Disable it first in order to call 'enable' again.`);
    }
    const facade = await createConditionInducer(this);
    this._conditionInducer = facade;
    try {
        return await facade.enable(conditionID, profileID);
    }
    catch (err) {
        this._conditionInducer = null;
        try {
            await facade.close();
        }
        catch { }
        throw this.log.errorWithException(`Condition inducer '${profileID}' cannot be enabled: '${err.message}'`);
    }
}
/**
 * Disable a condition inducer enabled with {@linkcode XCUITestDriver.enableConditionInducer} Usually
 * a persistent connection is maintained after the condition inducer is enabled, and this method
 * is only valid for the currently enabled connection. If the connection is disconnected, the
 * condition inducer will be automatically disabled
 *
 * (Note: this is also automatically called upon session cleanup)
 * @returns `true` if disable the condition succeeded
 * @since 4.9.0
 * @see {@link https://help.apple.com/xcode/mac/current/#/dev308429d42}
 */
async function disableConditionInducer() {
    (0, utils_1.requireRealDevice)(this, 'Condition inducer');
    if (!this._conditionInducer) {
        this.log.warn('Condition inducer is not active');
        return false;
    }
    try {
        return await this._conditionInducer.disable();
    }
    finally {
        try {
            await this._conditionInducer.close();
        }
        catch { }
        this._conditionInducer = null;
    }
}
// Private implementation classes and factory function
/**
 * RemoteXPC-based implementation for iOS 18+
 */
class RemoteXPCConditionInducer {
    udid;
    log;
    connection = null;
    constructor(udid, log) {
        this.udid = udid;
        this.log = log;
    }
    async list() {
        let connection = null;
        try {
            connection = await this.startConnection();
            const result = await connection.conditionInducer.list();
            return result;
        }
        catch (err) {
            this.log.error(`Failed to list condition inducers via RemoteXPC: ${err.message}`);
            throw err;
        }
        finally {
            if (connection) {
                this.log.info(`Closing remoteXPC connection for device ${this.udid}`);
                await connection.remoteXPC.close();
            }
        }
    }
    async enable(conditionID, profileID) {
        if (this.connection) {
            throw new Error(`Condition inducer is already running. Disable it first in order to call 'enable' again.`);
        }
        try {
            this.connection = await this.startConnection();
            await this.connection.conditionInducer.set(profileID);
            this.log.info(`Successfully enabled condition profile: ${profileID}`);
            return true;
        }
        catch (err) {
            await this.close();
            this.log.error(`Condition inducer '${profileID}' cannot be enabled: '${err.message}'`);
            throw err;
        }
    }
    async disable() {
        if (!this.connection) {
            this.log.warn('Condition inducer connection is not active');
            return false;
        }
        try {
            await this.connection.conditionInducer.disable();
            this.log.info('Successfully disabled condition inducer');
            return true;
        }
        catch (err) {
            this.log.warn(`Failed to disable condition inducer via RemoteXPC: ${err.message}`);
            return false;
        }
        finally {
            this.log.info(`Closing remoteXPC connection for device ${this.udid}`);
            await this.close();
        }
    }
    async close() {
        if (this.connection) {
            await this.connection.remoteXPC.close();
            this.connection = null;
        }
    }
    isActive() {
        return this.connection !== null;
    }
    async startConnection() {
        const Services = await (0, remotexpc_utils_1.getRemoteXPCServices)();
        return Services.startDVTService(this.udid);
    }
}
/**
 * Instrument Service-based implementation for iOS < 18
 */
class InstrumentConditionInducer {
    udid;
    log;
    service = null; // InstrumentService type from appium-ios-device
    constructor(udid, log) {
        this.udid = udid;
        this.log = log;
    }
    async list() {
        const service = await appium_ios_device_1.services.startInstrumentService(this.udid);
        try {
            const ret = await service.callChannel(appium_ios_device_1.INSTRUMENT_CHANNEL.CONDITION_INDUCER, 'availableConditionInducers');
            return ret.selector;
        }
        finally {
            service.close();
        }
    }
    async enable(conditionID, profileID) {
        if (this.service && !this.service._socketClient.destroyed) {
            throw new Error(`Condition inducer has been started. A condition is already active.`);
        }
        this.service = await appium_ios_device_1.services.startInstrumentService(this.udid);
        const ret = await this.service.callChannel(appium_ios_device_1.INSTRUMENT_CHANNEL.CONDITION_INDUCER, 'enableConditionWithIdentifier:profileIdentifier:', conditionID, profileID);
        if (!lodash_1.default.isBoolean(ret.selector)) {
            this.service.close();
            this.service = null;
            throw new Error(`Enable condition inducer error: '${JSON.stringify(ret.selector)}'`);
        }
        return ret.selector;
    }
    async disable() {
        if (!this.service) {
            this.log.warn('Condition inducer server has not started');
            return false;
        }
        try {
            const ret = await this.service.callChannel(appium_ios_device_1.INSTRUMENT_CHANNEL.CONDITION_INDUCER, 'disableActiveCondition');
            if (!lodash_1.default.isBoolean(ret.selector)) {
                this.log.warn(`Disable condition inducer error: '${JSON.stringify(ret.selector)}'`);
                return false;
            }
            return ret.selector;
        }
        finally {
            if (this.service) {
                this.service.close();
                this.service = null;
            }
        }
    }
    async close() {
        if (this.service) {
            this.service.close();
            this.service = null;
        }
    }
    isActive() {
        return this.service !== null && !this.service._socketClient.destroyed;
    }
}
/**
 * Factory function to create the appropriate condition inducer implementation
 * based on the iOS version
 */
async function createConditionInducer(driver) {
    if (!(0, utils_1.isIos18OrNewer)(driver.opts)) {
        return new InstrumentConditionInducer(driver.device.udid, driver.log);
    }
    const xpcInducer = new RemoteXPCConditionInducer(driver.device.udid, driver.log);
    try {
        const connection = await xpcInducer.startConnection();
        await connection.remoteXPC.close();
    }
    catch (err) {
        driver.log.warn(`Unable to use RemoteXPC-based condition inducer for device ${driver.device.udid}, ` +
            `falling back to the legacy implementation: ${err.message}`);
        return new InstrumentConditionInducer(driver.device.udid, driver.log);
    }
    return xpcInducer;
}
//# sourceMappingURL=condition.js.map