import type { XCUITestDriver } from '../driver';
import type { Method } from 'axios';
/**
 * Starts performance profiling for the device under test.
 *
 * Relaxing security is mandatory for simulators. It can always work for real devices.
 *
 * Since XCode 12 the method tries to use `xctrace` tool to record performance stats.
 *
 * The `instruments` developer utility is used as a fallback for this purpose if `xctrace` is not available.
 *
 * It is possible to record multiple profiles at the same time.
 *
 * Read [Recording, Pausing, and Stopping Traces](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/Recording,Pausing,andStoppingTraces.html) for more details.
 *
 * @param timeout - The maximum count of milliseconds to record the profiling information.
 * @param profileName - The name of existing performance profile to apply. Can also contain the full path to the chosen template on the server file system. Note: not all profiles are supported on mobile devices.
 * @param pid - The ID of the process to measure the performance for. Set it to `current` in order to measure the performance of the process, which belongs to the currently active application. All processes running on the device are measured if `pid` is unset (the default setting).
 */
export declare function mobileStartPerfRecord(this: XCUITestDriver, timeout?: number, profileName?: string, pid?: number | 'current'): Promise<void>;
/**
 * Stops performance recording operation previously started by {@linkcode XCUITestDriver.mobileStartPerfRecord mobile: startPerfRecord}.
 *
 * If the previous call has already been completed due to the timeout, then its result is returned immediately. An error is thrown if the performance recording failed to start.
 *
 * The resulting file in `.trace` format can be either returned directly as base64-encoded zip archive or uploaded to a remote location (such files can be pretty large). Afterwards it is possible to unarchive and open such files with Xcode Dev Tools.
 *
 * @param remotePath - The path to the remote location, where the resulting zipped `.trace` file should be uploaded. The following protocols are supported: `http`, `https`, `ftp`. Null or empty string value (the default setting) means the content of resulting file should be zipped, encoded as Base64 and passed as the endpoint response value. An exception will be thrown if the generated file is too big to fit into the available process memory.
 * @param user - The name of the user for the remote authentication. Only works if `remotePath` is provided.
 * @param pass - The password for the remote authentication. Only works if `remotePath` is provided.
 * @param method - The http multipart upload method name. Only works if `remotePath` is provided. Defaults to `PUT`
 * @param profileName - The name of existing performance profile to stop the recording for. Multiple recorders for different profile names could be executed at the same time.
 * @param headers - Additional headers mapping for multipart http(s) uploads
 * @param fileFieldName - The name of the form field, where the file content BLOB should be stored for http(s) uploads. Defaults to `file`
 * @param formFields - Additional form fields for multipart http(s) uploads
 * @returns The resulting file in `.trace` format. This file can either be returned directly as base64-encoded `.zip` archive or uploaded to a remote location (note that such files may be large), _depending on the `remotePath` argument value._ Thereafter, the file may be unarchived and opened with Xcode Developer Tools.
 * @throws {Error} If no performance recording with given profile name/device udid combination
 * has been started before or the resulting .trace file has not been generated properly.
 */
export declare function mobileStopPerfRecord(this: XCUITestDriver, remotePath?: string, user?: string, pass?: string, method?: Method, profileName?: string, headers?: Record<string, any>, fileFieldName?: string, formFields?: Record<string, any> | [string, any][]): Promise<string>;
export declare class PerfRecorder {
    private _process;
    private _zippedReportPath;
    private readonly _timeout;
    private readonly _profileName;
    private readonly _reportPath;
    private readonly _pid;
    private readonly _udid;
    private readonly _logger;
    private _archivePromise;
    constructor(reportRoot: string, udid: string, opts?: PerfRecorderOptions);
    get profileName(): string;
    getZippedReportPath(): Promise<string>;
    isRunning(): boolean;
    start(): Promise<void>;
    stop(force?: boolean): Promise<string>;
    private getOriginalReportPath;
    private _enforceTermination;
}
interface PerfRecorderOptions {
    timeout?: number;
    profileName?: string;
    pid?: number;
}
export {};
//# sourceMappingURL=performance.d.ts.map