import type { XCUITestDriver } from '../driver';
import type { AudioRecorderOptions } from './types';
export declare class AudioRecorder {
    private readonly input;
    private readonly log;
    private readonly audioPath;
    private readonly opts;
    private mainProcess;
    constructor(input: string | number, log: any, audioPath: string, opts?: AudioRecorderOptions);
    start(timeoutSeconds: number): Promise<void>;
    isRecording(): boolean;
    interrupt(force?: boolean): Promise<boolean>;
    finish(): Promise<string>;
    cleanup(): Promise<void>;
}
/**
 * Records the given hardware audio input and saves it into an `.mp4` file.
 *
 * **To use this command, the `audio_record` security feature must be enabled _and_ [FFMpeg](https://ffmpeg.org/) must be installed on the Appium server.**
 *
 * @param audioInput - The name of the corresponding audio input device to use for the capture. The full list of capture devices could be shown by executing `ffmpeg -f avfoundation -list_devices true -i ""`
 * @param timeLimit - The maximum recording time, in seconds.
 * @param audioCodec - The name of the audio codec.
 * @param audioBitrate - The bitrate of the resulting audio stream.
 * @param audioChannels - The count of audio channels in the resulting stream. Setting it to `1` will create a single channel (mono) audio stream.
 * @param audioRate - The sampling rate of the resulting audio stream (in Hz).
 * @param forceRestart - Whether to restart audio capture process forcefully when `mobile: startRecordingAudio` is called (`true`) or ignore the call until the current audio recording is completed (`false`).
 * @group Real Device Only
 */
export declare function startAudioRecording(this: XCUITestDriver, audioInput: string | number, timeLimit?: string | number, audioCodec?: string, audioBitrate?: string, audioChannels?: string | number, audioRate?: string | number, forceRestart?: boolean): Promise<void>;
/**
 * Stop recording of the audio input. If no audio recording process is running then
 * the endpoint will try to get the recently recorded file.
 * If no previously recorded file is found and no active audio recording
 * processes are running then the method returns an empty string.
 *
 * @returns Base64-encoded content of the recorded media file or an
 * empty string if no audio recording has been started before.
 * @throws {Error} If there was an error while getting the recorded file.
 */
export declare function stopAudioRecording(this: XCUITestDriver): Promise<string>;
//# sourceMappingURL=record-audio.d.ts.map