"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = __importStar(require("chai"));
const chai_as_promised_1 = __importDefault(require("chai-as-promised"));
const utils_1 = require("../../lib/utils");
const webdriveragent_1 = require("../../lib/webdriveragent");
const utils = __importStar(require("../../lib/utils"));
const path_1 = __importDefault(require("path"));
const lodash_1 = __importDefault(require("lodash"));
const sinon_1 = __importDefault(require("sinon"));
chai_1.default.use(chai_as_promised_1.default);
const fakeConstructorArgs = {
    device: {
        udid: 'some-sim-udid',
        simctl: {},
        devicectl: {},
        idb: null
    },
    platformVersion: '9',
    host: 'me',
    realDevice: false
};
const defaultAgentPath = path_1.default.resolve(utils_1.BOOTSTRAP_PATH, 'WebDriverAgent.xcodeproj');
const customBootstrapPath = '/path/to/wda';
const customAgentPath = '/path/to/some/agent/WebDriverAgent.xcodeproj';
const customDerivedDataPath = '/path/to/some/agent/DerivedData/';
describe('WebDriverAgent', function () {
    describe('Constructor', function () {
        it('should have a default wda agent if not specified', function () {
            const agent = new webdriveragent_1.WebDriverAgent(fakeConstructorArgs);
            (0, chai_1.expect)(agent.bootstrapPath).to.eql(utils_1.BOOTSTRAP_PATH);
            (0, chai_1.expect)(agent.agentPath).to.eql(defaultAgentPath);
        });
        it('should have custom wda bootstrap and default agent if only bootstrap specified', function () {
            const agent = new webdriveragent_1.WebDriverAgent(lodash_1.default.defaults({
                bootstrapPath: customBootstrapPath,
            }, fakeConstructorArgs));
            (0, chai_1.expect)(agent.bootstrapPath).to.eql(customBootstrapPath);
            (0, chai_1.expect)(agent.agentPath).to.eql(path_1.default.resolve(customBootstrapPath, 'WebDriverAgent.xcodeproj'));
        });
        it('should have custom wda bootstrap and agent if both specified', function () {
            const agent = new webdriveragent_1.WebDriverAgent(lodash_1.default.defaults({
                bootstrapPath: customBootstrapPath,
                agentPath: customAgentPath,
            }, fakeConstructorArgs));
            (0, chai_1.expect)(agent.bootstrapPath).to.eql(customBootstrapPath);
            (0, chai_1.expect)(agent.agentPath).to.eql(customAgentPath);
        });
        it('should have custom derivedDataPath if specified', function () {
            const agent = new webdriveragent_1.WebDriverAgent(lodash_1.default.defaults({
                derivedDataPath: customDerivedDataPath
            }, fakeConstructorArgs));
            if (agent.xcodebuild) {
                (0, chai_1.expect)(agent.xcodebuild.derivedDataPath).to.eql(customDerivedDataPath);
            }
        });
    });
    describe('launch', function () {
        it('should use webDriverAgentUrl override and return current status', async function () {
            const override = 'http://mockurl:8100/';
            const args = Object.assign({}, fakeConstructorArgs);
            args.webDriverAgentUrl = override;
            const agent = new webdriveragent_1.WebDriverAgent(args);
            const wdaStub = sinon_1.default.stub(agent, 'getStatus');
            wdaStub.callsFake(function () {
                return { build: 'data' };
            });
            await (0, chai_1.expect)(agent.launch('sessionId')).to.eventually.eql({ build: 'data' });
            (0, chai_1.expect)(agent.url.href).to.eql(override);
            if (agent.jwproxy) {
                (0, chai_1.expect)(agent.jwproxy.server).to.eql('mockurl');
                (0, chai_1.expect)(agent.jwproxy.port).to.eql(8100);
                (0, chai_1.expect)(agent.jwproxy.base).to.eql('');
                (0, chai_1.expect)(agent.jwproxy.scheme).to.eql('http');
            }
            if (agent.noSessionProxy) {
                (0, chai_1.expect)(agent.noSessionProxy.server).to.eql('mockurl');
                (0, chai_1.expect)(agent.noSessionProxy.port).to.eql(8100);
                (0, chai_1.expect)(agent.noSessionProxy.base).to.eql('');
                (0, chai_1.expect)(agent.noSessionProxy.scheme).to.eql('http');
            }
            wdaStub.reset();
        });
    });
    describe('use wda proxy url', function () {
        it('should use webDriverAgentUrl wda proxy url', async function () {
            const override = 'http://127.0.0.1:8100/aabbccdd';
            const args = Object.assign({}, fakeConstructorArgs);
            args.webDriverAgentUrl = override;
            const agent = new webdriveragent_1.WebDriverAgent(args);
            const wdaStub = sinon_1.default.stub(agent, 'getStatus');
            wdaStub.callsFake(function () {
                return { build: 'data' };
            });
            await (0, chai_1.expect)(agent.launch('sessionId')).to.eventually.eql({ build: 'data' });
            (0, chai_1.expect)(agent.url.port).to.eql('8100');
            (0, chai_1.expect)(agent.url.hostname).to.eql('127.0.0.1');
            (0, chai_1.expect)(agent.url.path).to.eql('/aabbccdd');
            if (agent.jwproxy) {
                (0, chai_1.expect)(agent.jwproxy.server).to.eql('127.0.0.1');
                (0, chai_1.expect)(agent.jwproxy.port).to.eql(8100);
                (0, chai_1.expect)(agent.jwproxy.base).to.eql('/aabbccdd');
                (0, chai_1.expect)(agent.jwproxy.scheme).to.eql('http');
            }
            if (agent.noSessionProxy) {
                (0, chai_1.expect)(agent.noSessionProxy.server).to.eql('127.0.0.1');
                (0, chai_1.expect)(agent.noSessionProxy.port).to.eql(8100);
                (0, chai_1.expect)(agent.noSessionProxy.base).to.eql('/aabbccdd');
                (0, chai_1.expect)(agent.noSessionProxy.scheme).to.eql('http');
            }
        });
    });
    describe('get url', function () {
        it('should use default WDA listening url', function () {
            const args = Object.assign({}, fakeConstructorArgs);
            const agent = new webdriveragent_1.WebDriverAgent(args);
            (0, chai_1.expect)(agent.url.href).to.eql('http://127.0.0.1:8100/');
            agent.setupProxies('mysession');
            if (agent.jwproxy) {
                (0, chai_1.expect)(agent.jwproxy.scheme).to.eql('http');
            }
            if (agent.noSessionProxy) {
                (0, chai_1.expect)(agent.noSessionProxy.scheme).to.eql('http');
            }
        });
        it('should use default WDA listening url with emply base url', function () {
            const wdaLocalPort = '9100';
            const wdaBaseUrl = '';
            const args = Object.assign({}, fakeConstructorArgs);
            args.wdaBaseUrl = wdaBaseUrl;
            args.wdaLocalPort = parseInt(wdaLocalPort, 10);
            const agent = new webdriveragent_1.WebDriverAgent(args);
            (0, chai_1.expect)(agent.url.href).to.eql('http://127.0.0.1:9100/');
            agent.setupProxies('mysession');
            if (agent.jwproxy) {
                (0, chai_1.expect)(agent.jwproxy.scheme).to.eql('http');
            }
            if (agent.noSessionProxy) {
                (0, chai_1.expect)(agent.noSessionProxy.scheme).to.eql('http');
            }
        });
        it('should use customised WDA listening url', function () {
            const wdaLocalPort = '9100';
            const wdaBaseUrl = 'http://mockurl';
            const args = Object.assign({}, fakeConstructorArgs);
            args.wdaBaseUrl = wdaBaseUrl;
            args.wdaLocalPort = parseInt(wdaLocalPort, 10);
            const agent = new webdriveragent_1.WebDriverAgent(args);
            (0, chai_1.expect)(agent.url.href).to.eql('http://mockurl:9100/');
            agent.setupProxies('mysession');
            if (agent.jwproxy) {
                (0, chai_1.expect)(agent.jwproxy.scheme).to.eql('http');
            }
            if (agent.noSessionProxy) {
                (0, chai_1.expect)(agent.noSessionProxy.scheme).to.eql('http');
            }
        });
        it('should use customised WDA listening url with slash', function () {
            const wdaLocalPort = '9100';
            const wdaBaseUrl = 'http://mockurl/';
            const args = Object.assign({}, fakeConstructorArgs);
            args.wdaBaseUrl = wdaBaseUrl;
            args.wdaLocalPort = parseInt(wdaLocalPort, 10);
            const agent = new webdriveragent_1.WebDriverAgent(args);
            (0, chai_1.expect)(agent.url.href).to.eql('http://mockurl:9100/');
            agent.setupProxies('mysession');
            if (agent.jwproxy) {
                (0, chai_1.expect)(agent.jwproxy.scheme).to.eql('http');
            }
            if (agent.noSessionProxy) {
                (0, chai_1.expect)(agent.noSessionProxy.scheme).to.eql('http');
            }
        });
        it('should use the given webDriverAgentUrl and ignore other params', function () {
            const args = Object.assign({}, fakeConstructorArgs);
            args.wdaBaseUrl = 'http://mockurl/';
            args.wdaLocalPort = 9100;
            args.webDriverAgentUrl = 'https://127.0.0.1:8100/';
            const agent = new webdriveragent_1.WebDriverAgent(args);
            (0, chai_1.expect)(agent.url.href).to.eql('https://127.0.0.1:8100/');
        });
        it('should set scheme to https for https webDriverAgentUrl', function () {
            const args = Object.assign({}, fakeConstructorArgs);
            args.webDriverAgentUrl = 'https://127.0.0.1:8100/';
            const agent = new webdriveragent_1.WebDriverAgent(args);
            agent.setupProxies('mysession');
            if (agent.jwproxy) {
                (0, chai_1.expect)(agent.jwproxy.scheme).to.eql('https');
            }
            if (agent.noSessionProxy) {
                (0, chai_1.expect)(agent.noSessionProxy.scheme).to.eql('https');
            }
        });
    });
    describe('setupCaching()', function () {
        let wda;
        let wdaStub;
        let wdaStubUninstall;
        const getTimestampStub = sinon_1.default.stub(utils, 'getWDAUpgradeTimestamp');
        beforeEach(function () {
            wda = new webdriveragent_1.WebDriverAgent(fakeConstructorArgs);
            wdaStub = sinon_1.default.stub(wda, 'getStatus');
            wdaStubUninstall = sinon_1.default.stub(wda, 'uninstall');
        });
        afterEach(function () {
            for (const stub of [wdaStub, wdaStubUninstall, getTimestampStub]) {
                if (stub) {
                    stub.reset();
                }
            }
        });
        it('should not call uninstall since no Running WDA', async function () {
            wdaStub.callsFake(function () {
                return null;
            });
            wdaStubUninstall.callsFake(lodash_1.default.noop);
            await wda.setupCaching();
            (0, chai_1.expect)(wdaStub.calledOnce).to.be.true;
            (0, chai_1.expect)(wdaStubUninstall.notCalled).to.be.true;
            (0, chai_1.expect)(lodash_1.default.isUndefined(wda.webDriverAgentUrl)).to.be.true;
        });
        it('should not call uninstall since running WDA has only time', async function () {
            wdaStub.callsFake(function () {
                return { build: { time: 'Jun 24 2018 17:08:21' } };
            });
            wdaStubUninstall.callsFake(lodash_1.default.noop);
            await wda.setupCaching();
            (0, chai_1.expect)(wdaStub.calledOnce).to.be.true;
            (0, chai_1.expect)(wdaStubUninstall.notCalled).to.be.true;
            (0, chai_1.expect)(wda.webDriverAgentUrl).to.equal('http://127.0.0.1:8100/');
        });
        it('should call uninstall once since bundle id is not default without updatedWDABundleId capability', async function () {
            wdaStub.callsFake(function () {
                return { build: { time: 'Jun 24 2018 17:08:21', productBundleIdentifier: 'com.example.WebDriverAgent' } };
            });
            wdaStubUninstall.callsFake(lodash_1.default.noop);
            await wda.setupCaching();
            (0, chai_1.expect)(wdaStub.calledOnce).to.be.true;
            (0, chai_1.expect)(wdaStubUninstall.calledOnce).to.be.true;
            (0, chai_1.expect)(lodash_1.default.isUndefined(wda.webDriverAgentUrl)).to.be.true;
        });
        it('should call uninstall once since bundle id is different with updatedWDABundleId capability', async function () {
            wdaStub.callsFake(function () {
                return { build: { time: 'Jun 24 2018 17:08:21', productBundleIdentifier: 'com.example.different.WebDriverAgent' } };
            });
            wdaStubUninstall.callsFake(lodash_1.default.noop);
            await wda.setupCaching();
            (0, chai_1.expect)(wdaStub.calledOnce).to.be.true;
            (0, chai_1.expect)(wdaStubUninstall.calledOnce).to.be.true;
            (0, chai_1.expect)(lodash_1.default.isUndefined(wda.webDriverAgentUrl)).to.be.true;
        });
        it('should not call uninstall since bundle id is equal to updatedWDABundleId capability', async function () {
            wda = new webdriveragent_1.WebDriverAgent({ ...fakeConstructorArgs, updatedWDABundleId: 'com.example.WebDriverAgent' });
            wdaStub = sinon_1.default.stub(wda, 'getStatus');
            wdaStubUninstall = sinon_1.default.stub(wda, 'uninstall');
            wdaStub.callsFake(function () {
                return { build: { time: 'Jun 24 2018 17:08:21', productBundleIdentifier: 'com.example.WebDriverAgent' } };
            });
            wdaStubUninstall.callsFake(lodash_1.default.noop);
            await wda.setupCaching();
            (0, chai_1.expect)(wdaStub.calledOnce).to.be.true;
            (0, chai_1.expect)(wdaStubUninstall.notCalled).to.be.true;
            (0, chai_1.expect)(wda.webDriverAgentUrl).to.equal('http://127.0.0.1:8100/');
        });
        it('should call uninstall if current revision differs from the bundled one', async function () {
            wdaStub.callsFake(function () {
                return { build: { upgradedAt: '1' } };
            });
            getTimestampStub.callsFake(() => '2');
            wdaStubUninstall.callsFake(lodash_1.default.noop);
            await wda.setupCaching();
            (0, chai_1.expect)(wdaStub.calledOnce).to.be.true;
            (0, chai_1.expect)(wdaStubUninstall.calledOnce).to.be.true;
        });
        it('should not call uninstall if current revision is the same as the bundled one', async function () {
            wdaStub.callsFake(function () {
                return { build: { upgradedAt: '1' } };
            });
            getTimestampStub.callsFake(() => '1');
            wdaStubUninstall.callsFake(lodash_1.default.noop);
            await wda.setupCaching();
            (0, chai_1.expect)(wdaStub.calledOnce).to.be.true;
            (0, chai_1.expect)(wdaStubUninstall.notCalled).to.be.true;
        });
        it('should not call uninstall if current revision cannot be retrieved from WDA status', async function () {
            wdaStub.callsFake(function () {
                return { build: {} };
            });
            getTimestampStub.callsFake(() => '1');
            wdaStubUninstall.callsFake(lodash_1.default.noop);
            await wda.setupCaching();
            (0, chai_1.expect)(wdaStub.calledOnce).to.be.true;
            (0, chai_1.expect)(wdaStubUninstall.notCalled).to.be.true;
        });
        it('should not call uninstall if current revision cannot be retrieved from the file system', async function () {
            wdaStub.callsFake(function () {
                return { build: { upgradedAt: '1' } };
            });
            getTimestampStub.callsFake(() => null);
            wdaStubUninstall.callsFake(lodash_1.default.noop);
            await wda.setupCaching();
            (0, chai_1.expect)(wdaStub.calledOnce).to.be.true;
            (0, chai_1.expect)(wdaStubUninstall.notCalled).to.be.true;
        });
        describe('uninstall', function () {
            let device;
            let wda;
            let deviceGetBundleIdsStub;
            let deviceRemoveAppStub;
            beforeEach(function () {
                device = {
                    getUserInstalledBundleIdsByBundleName: () => { },
                    removeApp: () => { }
                };
                wda = new webdriveragent_1.WebDriverAgent({ device });
                deviceGetBundleIdsStub = sinon_1.default.stub(device, 'getUserInstalledBundleIdsByBundleName');
                deviceRemoveAppStub = sinon_1.default.stub(device, 'removeApp');
            });
            afterEach(function () {
                for (const stub of [deviceGetBundleIdsStub, deviceRemoveAppStub]) {
                    if (stub) {
                        stub.reset();
                    }
                }
            });
            it('should not call uninstall', async function () {
                deviceGetBundleIdsStub.callsFake(() => []);
                await wda.uninstall();
                (0, chai_1.expect)(deviceGetBundleIdsStub.calledOnce).to.be.true;
                (0, chai_1.expect)(deviceRemoveAppStub.notCalled).to.be.true;
            });
            it('should call uninstall once', async function () {
                const uninstalledBundIds = [];
                deviceGetBundleIdsStub.callsFake(() => ['com.appium.WDA1']);
                deviceRemoveAppStub.callsFake((id) => uninstalledBundIds.push(id));
                await wda.uninstall();
                (0, chai_1.expect)(deviceGetBundleIdsStub.calledOnce).to.be.true;
                (0, chai_1.expect)(deviceRemoveAppStub.calledOnce).to.be.true;
                (0, chai_1.expect)(uninstalledBundIds).to.eql(['com.appium.WDA1']);
            });
            it('should call uninstall twice', async function () {
                const uninstalledBundIds = [];
                deviceGetBundleIdsStub.callsFake(() => ['com.appium.WDA1', 'com.appium.WDA2']);
                deviceRemoveAppStub.callsFake((id) => uninstalledBundIds.push(id));
                await wda.uninstall();
                (0, chai_1.expect)(deviceGetBundleIdsStub.calledOnce).to.be.true;
                (0, chai_1.expect)(deviceRemoveAppStub.calledTwice).to.be.true;
                (0, chai_1.expect)(uninstalledBundIds).to.eql(['com.appium.WDA1', 'com.appium.WDA2']);
            });
        });
    });
    describe('usePreinstalledWDA related functions', function () {
        describe('bundleIdForXctest', function () {
            it('should have xctrunner automatically', function () {
                const args = Object.assign({}, fakeConstructorArgs);
                args.updatedWDABundleId = 'io.appium.wda';
                const agent = new webdriveragent_1.WebDriverAgent(args);
                (0, chai_1.expect)(agent.bundleIdForXctest).to.equal('io.appium.wda.xctrunner');
            });
            it('should have xctrunner automatically with default bundle id', function () {
                const args = Object.assign({}, fakeConstructorArgs);
                const agent = new webdriveragent_1.WebDriverAgent(args);
                (0, chai_1.expect)(agent.bundleIdForXctest).to.equal('com.facebook.WebDriverAgentRunner.xctrunner');
            });
            it('should allow an empty string as xctrunner suffix', function () {
                const args = Object.assign({}, fakeConstructorArgs);
                args.updatedWDABundleId = 'io.appium.wda';
                args.updatedWDABundleIdSuffix = '';
                const agent = new webdriveragent_1.WebDriverAgent(args);
                (0, chai_1.expect)(agent.bundleIdForXctest).to.equal('io.appium.wda');
            });
            it('should allow an empty string as xctrunner suffix with default bundle id', function () {
                const args = Object.assign({}, fakeConstructorArgs);
                args.updatedWDABundleIdSuffix = '';
                const agent = new webdriveragent_1.WebDriverAgent(args);
                (0, chai_1.expect)(agent.bundleIdForXctest).to.equal('com.facebook.WebDriverAgentRunner');
            });
            it('should have an arbitrary xctrunner suffix', function () {
                const args = Object.assign({}, fakeConstructorArgs);
                args.updatedWDABundleId = 'io.appium.wda';
                args.updatedWDABundleIdSuffix = '.customsuffix';
                const agent = new webdriveragent_1.WebDriverAgent(args);
                (0, chai_1.expect)(agent.bundleIdForXctest).to.equal('io.appium.wda.customsuffix');
            });
        });
    });
});
//# sourceMappingURL=webdriveragent-specs.js.map