"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Simctl = void 0;
const lodash_1 = __importDefault(require("lodash"));
const which_1 = __importDefault(require("which"));
const logger_1 = require("./logger");
const helpers_1 = require("./helpers");
const teen_process_1 = require("teen_process");
const addmediaCommands = __importStar(require("./subcommands/addmedia"));
const appinfoCommands = __importStar(require("./subcommands/appinfo"));
const bootCommands = __importStar(require("./subcommands/boot"));
const bootstatusCommands = __importStar(require("./subcommands/bootstatus"));
const createCommands = __importStar(require("./subcommands/create"));
const deleteCommands = __importStar(require("./subcommands/delete"));
const eraseCommands = __importStar(require("./subcommands/erase"));
const getappcontainerCommands = __importStar(require("./subcommands/get_app_container"));
const installCommands = __importStar(require("./subcommands/install"));
const ioCommands = __importStar(require("./subcommands/io"));
const keychainCommands = __importStar(require("./subcommands/keychain"));
const launchCommands = __importStar(require("./subcommands/launch"));
const listCommands = __importStar(require("./subcommands/list"));
const openurlCommands = __importStar(require("./subcommands/openurl"));
const pbcopyCommands = __importStar(require("./subcommands/pbcopy"));
const pbpasteCommands = __importStar(require("./subcommands/pbpaste"));
const privacyCommands = __importStar(require("./subcommands/privacy"));
const pushCommands = __importStar(require("./subcommands/push"));
const envCommands = __importStar(require("./subcommands/getenv"));
const shutdownCommands = __importStar(require("./subcommands/shutdown"));
const spawnCommands = __importStar(require("./subcommands/spawn"));
const terminateCommands = __importStar(require("./subcommands/terminate"));
const uiCommands = __importStar(require("./subcommands/ui"));
const uninstallCommands = __importStar(require("./subcommands/uninstall"));
const locationCommands = __importStar(require("./subcommands/location"));
const SIMCTL_ENV_PREFIX = 'SIMCTL_CHILD_';
class Simctl {
    xcrun;
    execTimeout;
    logErrors;
    _udid;
    _devicesSetPath;
    constructor(opts = {}) {
        this.xcrun = lodash_1.default.cloneDeep(opts.xcrun ?? { path: null });
        this.execTimeout = opts.execTimeout ?? helpers_1.DEFAULT_EXEC_TIMEOUT;
        this.logErrors = opts.logErrors ?? true;
        this._udid = opts.udid ?? null;
        this._devicesSetPath = opts.devicesSetPath ?? null;
    }
    set udid(value) {
        this._udid = value;
    }
    get udid() {
        return this._udid;
    }
    set devicesSetPath(value) {
        this._devicesSetPath = value;
    }
    get devicesSetPath() {
        return this._devicesSetPath;
    }
    /**
     * @param commandName - Optional command name for error message
     * @returns The UDID string
     * @throws {Error} If UDID is not set
     */
    requireUdid(commandName = null) {
        if (!this.udid) {
            throw new Error(`udid is required to be set for ` +
                (commandName ? `the '${commandName}' command` : 'this simctl command'));
        }
        return this.udid;
    }
    /**
     * @returns Promise resolving to the xcrun binary path
     */
    async requireXcrun() {
        const xcrunBinary = (0, helpers_1.getXcrunBinary)();
        if (!this.xcrun.path) {
            try {
                this.xcrun.path = await (0, which_1.default)(xcrunBinary);
            }
            catch {
                throw new Error(`${xcrunBinary} tool has not been found in PATH. ` +
                    `Are Xcode developers tools installed?`);
            }
        }
        if (!this.xcrun.path) {
            throw new Error(`${xcrunBinary} tool path is not set`);
        }
        return this.xcrun.path;
    }
    /**
     * Execute the particular simctl command.
     *
     * @param subcommand - One of available simctl subcommands.
     * Execute `xcrun simctl` in Terminal to see the full list  of available subcommands.
     * @param opts - Execution options
     * @return Either the result of teen process's `exec` or
     * `SubProcess` instance depending of `opts.asynchronous` value.
     * @throws {Error} If the simctl subcommand command returns non-zero return code.
     */
    async exec(subcommand, opts) {
        const { args: initialArgs = [], env: initialEnv = {}, asynchronous = false, encoding, logErrors = true, architectures, timeout, } = opts ?? {};
        // run a particular simctl command
        const args = [
            'simctl',
            ...(this.devicesSetPath ? ['--set', this.devicesSetPath] : []),
            subcommand,
            ...initialArgs
        ];
        // Prefix all passed in environment variables with 'SIMCTL_CHILD_', simctl
        // will then pass these to the child (spawned) process.
        const env = lodash_1.default.defaults(lodash_1.default.mapKeys(initialEnv, (value, key) => lodash_1.default.startsWith(key, SIMCTL_ENV_PREFIX) ? key : `${SIMCTL_ENV_PREFIX}${key}`), process.env);
        const execOpts = {
            env,
            encoding,
        };
        if (!asynchronous) {
            execOpts.timeout = timeout || this.execTimeout;
        }
        const xcrun = await this.requireXcrun();
        try {
            let execArgs;
            if (architectures?.length) {
                const archArgs = lodash_1.default.flatMap((lodash_1.default.isArray(architectures) ? architectures : [architectures]).map((arch) => ['-arch', arch]));
                execArgs = ['arch', [...archArgs, xcrun, ...args], execOpts];
            }
            else {
                execArgs = [xcrun, args, execOpts];
            }
            // We know what we are doing here - the type system can't handle the dynamic nature
            return (asynchronous ? new teen_process_1.SubProcess(...execArgs) : await (0, teen_process_1.exec)(...execArgs));
        }
        catch (e) {
            if (!this.logErrors || !logErrors) {
                // if we don't want to see the errors, just throw and allow the calling
                // code do what it wants
            }
            else if (e.stderr) {
                const msg = `Error running '${subcommand}': ${e.stderr.trim()}`;
                logger_1.log.debug(logger_1.LOG_PREFIX, msg);
                e.message = msg;
            }
            else {
                logger_1.log.debug(logger_1.LOG_PREFIX, e.message);
            }
            throw e;
        }
    }
    // Extension methods
    addMedia = addmediaCommands.addMedia;
    appInfo = appinfoCommands.appInfo;
    bootDevice = bootCommands.bootDevice;
    startBootMonitor = bootstatusCommands.startBootMonitor;
    createDevice = createCommands.createDevice;
    deleteDevice = deleteCommands.deleteDevice;
    eraseDevice = eraseCommands.eraseDevice;
    getAppContainer = getappcontainerCommands.getAppContainer;
    getEnv = envCommands.getEnv;
    installApp = installCommands.installApp;
    getScreenshot = ioCommands.getScreenshot;
    addRootCertificate = keychainCommands.addRootCertificate;
    addCertificate = keychainCommands.addCertificate;
    resetKeychain = keychainCommands.resetKeychain;
    launchApp = launchCommands.launchApp;
    getDevicesByParsing = listCommands.getDevicesByParsing;
    getDevices = listCommands.getDevices;
    getRuntimeForPlatformVersionViaJson = listCommands.getRuntimeForPlatformVersionViaJson;
    getRuntimeForPlatformVersion = listCommands.getRuntimeForPlatformVersion;
    getDeviceTypes = listCommands.getDeviceTypes;
    list = listCommands.list;
    setLocation = locationCommands.setLocation;
    clearLocation = locationCommands.clearLocation;
    openUrl = openurlCommands.openUrl;
    setPasteboard = pbcopyCommands.setPasteboard;
    getPasteboard = pbpasteCommands.getPasteboard;
    grantPermission = privacyCommands.grantPermission;
    revokePermission = privacyCommands.revokePermission;
    resetPermission = privacyCommands.resetPermission;
    pushNotification = pushCommands.pushNotification;
    shutdownDevice = shutdownCommands.shutdownDevice;
    spawnProcess = spawnCommands.spawnProcess;
    spawnSubProcess = spawnCommands.spawnSubProcess;
    terminateApp = terminateCommands.terminateApp;
    getAppearance = uiCommands.getAppearance;
    setAppearance = uiCommands.setAppearance;
    getIncreaseContrast = uiCommands.getIncreaseContrast;
    setIncreaseContrast = uiCommands.setIncreaseContrast;
    getContentSize = uiCommands.getContentSize;
    setContentSize = uiCommands.setContentSize;
    removeApp = uninstallCommands.removeApp;
}
exports.Simctl = Simctl;
exports.default = Simctl;
//# sourceMappingURL=simctl.js.map