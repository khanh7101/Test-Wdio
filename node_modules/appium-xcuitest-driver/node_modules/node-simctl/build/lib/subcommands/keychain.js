"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.addRootCertificate = addRootCertificate;
exports.addCertificate = addCertificate;
exports.resetKeychain = resetKeychain;
const os_1 = __importDefault(require("os"));
const promises_1 = __importDefault(require("fs/promises"));
const helpers_1 = require("../helpers");
const path_1 = __importDefault(require("path"));
const lodash_1 = __importDefault(require("lodash"));
const rimraf_1 = require("rimraf");
/**
 * @param payload - Certificate payload (string or Buffer)
 * @param onPayloadStored - Callback function to execute with the file path
 */
async function handleRawPayload(payload, onPayloadStored) {
    const filePath = path_1.default.resolve(os_1.default.tmpdir(), `${await (0, helpers_1.uuidV4)()}.pem`);
    try {
        if (lodash_1.default.isBuffer(payload)) {
            await promises_1.default.writeFile(filePath, payload);
        }
        else {
            await promises_1.default.writeFile(filePath, payload, 'utf8');
        }
        await onPayloadStored(filePath);
    }
    finally {
        await (0, rimraf_1.rimraf)(filePath);
    }
}
/**
 * Adds the given certificate to the Trusted Root Store on the simulator
 *
 * @since Xcode 11.4 SDK
 * @param cert the full path to a valid .cert file containing
 * the certificate content or the certificate content itself, depending on
 * options
 * @param opts - Certificate options
 * @throws {Error} if the current SDK version does not support the command
 * or there was an error while adding the certificate
 * @throws {Error} If the `udid` instance property is unset
 */
async function addRootCertificate(cert, opts = {}) {
    const { raw = false, } = opts;
    const execMethod = async (certPath) => await this.exec('keychain', {
        args: [this.requireUdid('keychain add-root-cert'), 'add-root-cert', certPath],
    });
    if (raw) {
        await handleRawPayload(cert, execMethod);
    }
    else {
        await execMethod(cert);
    }
}
/**
 * Adds the given certificate to the Keychain Store on the simulator
 *
 * @since Xcode 11.4 SDK
 * @param cert the full path to a valid .cert file containing
 * the certificate content or the certificate content itself, depending on
 * options
 * @param opts - Certificate options
 * @throws {Error} if the current SDK version does not support the command
 * or there was an error while adding the certificate
 * @throws {Error} If the `udid` instance property is unset
 */
async function addCertificate(cert, opts = {}) {
    const { raw = false, } = opts;
    const execMethod = async (certPath) => await this.exec('keychain', {
        args: [this.requireUdid('keychain add-cert'), 'add-cert', certPath],
    });
    if (raw) {
        await handleRawPayload(cert, execMethod);
    }
    else {
        await execMethod(cert);
    }
}
/**
 * Resets the simulator keychain
 *
 * @since Xcode 11.4 SDK
 * @throws {Error} if the current SDK version does not support the command
 * or there was an error while resetting the keychain
 * @throws {Error} If the `udid` instance property is unset
 */
async function resetKeychain() {
    await this.exec('keychain', {
        args: [this.requireUdid('keychain reset'), 'reset'],
    });
}
//# sourceMappingURL=keychain.js.map