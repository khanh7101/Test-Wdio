"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.startBootMonitor = startBootMonitor;
const logger_1 = require("../logger");
const asyncbox_1 = require("asyncbox");
const lodash_1 = __importDefault(require("lodash"));
/**
 * Start monitoring for boot status of the particular Simulator.
 * If onFinished property is not set then the method will block
 * until Simulator booting is completed.
 * The method is only available since Xcode8.
 *
 * @param opts - Monitoring options.
 * @returns The instance of the corresponding monitoring process.
 * @throws {Error} If the Simulator fails to finish booting within the given timeout and onFinished
 * property is not set.
 * @throws {Error} If the `udid` instance property is unset
 */
async function startBootMonitor(opts = {}) {
    const { timeout = 240000, onWaitingDataMigration, onWaitingSystemApp, onFinished, onError, shouldPreboot, } = opts;
    const udid = this.requireUdid('bootstatus');
    const status = [];
    let isBootingFinished = false;
    let error = null;
    let timeoutHandler = null;
    const args = [udid];
    if (shouldPreboot) {
        args.push('-b');
    }
    const bootMonitor = await this.exec('bootstatus', {
        args,
        asynchronous: true,
    });
    const onStreamLine = (line) => {
        status.push(line);
        if (onWaitingDataMigration && line.includes('Waiting on Data Migration')) {
            onWaitingDataMigration();
        }
        else if (onWaitingSystemApp && line.includes('Waiting on System App')) {
            onWaitingSystemApp();
        }
    };
    for (const streamName of ['stdout', 'stderr']) {
        bootMonitor.on(`line-${streamName}`, onStreamLine);
    }
    bootMonitor.once('exit', (code, signal) => {
        if (timeoutHandler) {
            clearTimeout(timeoutHandler);
        }
        if (code === 0) {
            if (onFinished) {
                onFinished();
            }
            isBootingFinished = true;
        }
        else {
            const errMessage = lodash_1.default.isEmpty(status)
                ? `The simulator booting process has exited with code ${code} by signal ${signal}`
                : status.join('\n');
            error = new Error(errMessage);
            if (onError) {
                onError(error);
            }
        }
    });
    await bootMonitor.start(0);
    const stopMonitor = async () => {
        if (bootMonitor.isRunning) {
            try {
                await bootMonitor.stop();
            }
            catch (e) {
                logger_1.log.warn(e.message);
            }
        }
    };
    const start = process.hrtime();
    if (onFinished) {
        timeoutHandler = setTimeout(stopMonitor, timeout);
    }
    else {
        try {
            await (0, asyncbox_1.waitForCondition)(() => {
                if (error) {
                    throw error;
                }
                return isBootingFinished;
            }, { waitMs: timeout, intervalMs: 500 });
        }
        catch {
            await stopMonitor();
            const [seconds] = process.hrtime(start);
            throw new Error(`The simulator ${udid} has failed to finish booting after ${seconds}s. ` +
                `Original status: ${status.join('\n')}`);
        }
    }
    return bootMonitor;
}
//# sourceMappingURL=bootstatus.js.map