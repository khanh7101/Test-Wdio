"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const helpers_1 = require("../../helpers/helpers");
const execute_1 = require("../../../lib/mixins/execute");
const sinon_1 = __importDefault(require("sinon"));
const chai_1 = require("chai");
describe('execute', function () {
    this.timeout(helpers_1.MOCHA_TIMEOUT);
    describe('executeAtom', function () {
        it('should execute atom and call send event on rpc client', async function () {
            const ctx = {
                _appIdKey: 'appId',
                _pageIdKey: 'pageId',
                log: { debug: () => { } },
                execute: execute_1.execute,
                _rpcClient: {
                    isConnected: true,
                    send: () => ({ hello: 'world' }),
                    waitForPage: async () => { },
                },
                requireRpcClient() {
                    return this._rpcClient;
                }
            };
            const res = await execute_1.executeAtom.call(ctx, 'find_element', ['css selector', '#id', { ELEMENT: 'foo' }]);
            (0, chai_1.expect)(res).to.eql({ hello: 'world' });
        });
    });
    describe('.executeAtomAsync', function () {
        it('calls rpcClient.send', async function () {
            const ctx = {
                _appIdKey: 'appId',
                _pageIdKey: 'pageId',
                log: { debug: () => { } },
                execute: execute_1.execute,
                _rpcClient: {
                    isConnected: true,
                    send: () => ({ result: { objectId: 'fake-object-id' } }),
                    waitForPage: async () => { },
                },
                requireRpcClient() {
                    return this._rpcClient;
                }
            };
            const sendSpy = sinon_1.default.spy(ctx._rpcClient, 'send');
            await execute_1.executeAtomAsync.call(ctx, 'find_element', ['a', 'b', 'c'], ['frame-1'], ['frame-2']);
            const callArgs = sendSpy.firstCall.args;
            (0, chai_1.expect)(callArgs[0]).to.equal('Runtime.evaluate');
            (0, chai_1.expect)(callArgs[1].appIdKey).to.equal('appId');
        });
    });
    describe('.callFunction', function () {
        it('call rpcClient.send', async function () {
            const ctx = {
                _appIdKey: 'fakeAppId',
                _pageIdKey: 'fakePageId',
                log: { debug: () => { } },
                _garbageCollectOnExecute: true,
                garbageCollect() { },
                _rpcClient: {
                    send() {
                        return { result: { objectId: 'fake-object-id' } };
                    },
                    isConnected: true,
                    waitForPage: async () => { },
                },
                waitForDom() { },
                _pageLoading: true,
                requireRpcClient() {
                    return this._rpcClient;
                }
            };
            const sendSpy = sinon_1.default.spy(ctx._rpcClient, 'send');
            await execute_1.callFunction.call(ctx, 'fake-object-id', 'fake_function', ['a', 'b', 'c']);
            (0, chai_1.expect)(sendSpy.firstCall.args[0]).to.equal('Runtime.callFunctionOn');
            (0, chai_1.expect)(sendSpy.firstCall.args[1]).to.eql({
                appIdKey: 'fakeAppId',
                arguments: [
                    'a',
                    'b',
                    'c',
                ],
                functionDeclaration: 'fake_function',
                objectId: 'fake-object-id',
                pageIdKey: 'fakePageId',
                returnByValue: true,
            });
        });
    });
});
//# sourceMappingURL=execute-specs.js.map