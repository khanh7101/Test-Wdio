var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _TestRunner_instances, _TestRunner_child, _TestRunner_lastPayload, _TestRunner_baseDir, _TestRunner_buildFilters, _TestRunner_buildSpecArgument, _TestRunner_resolveLineNumber, _TestRunner_normaliseSpecFile, _TestRunner_getSpecCandidate, _TestRunner_extractSpecFromCallSource, _TestRunner_toFsPath, _TestRunner_resolveConfigPath, _TestRunner_findConfigFromSpec, _TestRunner_expandDefaultConfigsFor, _TestRunner_dedupeCandidates;
import { spawn } from 'node:child_process';
import fs from 'node:fs';
import path from 'node:path';
import url from 'node:url';
import { createRequire } from 'node:module';
import kill from 'tree-kill';
import { WDIO_CONFIG_FILENAMES } from './types.js';
const require = createRequire(import.meta.url);
const wdioBin = resolveWdioBin();
/**
 * Escape special regex characters in a string
 */
function escapeRegex(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
const FRAMEWORK_FILTERS = {
    cucumber: ({ specArg, payload }) => {
        const filters = [];
        // For feature-level suites, run the entire feature file
        if (payload.suiteType === 'feature' && specArg) {
            // Remove any line number from specArg for feature-level execution
            const featureFile = specArg.split(':')[0];
            filters.push('--spec', featureFile);
            return filters;
        }
        // Priority 1: Use feature file with line number for exact scenario targeting (works for examples)
        // Note: Cucumber scenarios are type 'suite', not 'test'
        if (payload.featureFile && payload.featureLine) {
            filters.push('--spec', `${payload.featureFile}:${payload.featureLine}`);
            return filters;
        }
        // Priority 2: For specific test reruns with example row number, use exact regex match
        if (payload.entryType === 'test' && payload.fullTitle) {
            // Cucumber fullTitle format: "1: Scenario name" or "2: Scenario name"
            // Extract the row number and scenario name
            // Avoid ReDoS by removing ambiguous \s* before .* - use string operations instead
            const colonIndex = payload.fullTitle.indexOf(':');
            if (colonIndex > 0) {
                const rowNumber = payload.fullTitle.substring(0, colonIndex);
                const scenarioName = payload.fullTitle.substring(colonIndex + 1).trim();
                // Validate row number is digits only
                if (/^\d+$/.test(rowNumber)) {
                    // Use spec file filter
                    if (specArg) {
                        filters.push('--spec', specArg);
                    }
                    // Use regex to match the exact "rowNumber: scenarioName" pattern
                    // This ensures we only run that specific example row
                    filters.push('--cucumberOpts.name', `^${rowNumber}:\\s*${escapeRegex(scenarioName)}$`);
                    return filters;
                }
            }
            // No row number - use plain name filter
            if (specArg) {
                filters.push('--spec', specArg);
            }
            filters.push('--cucumberOpts.name', payload.fullTitle.trim());
            return filters;
        }
        // Suite-level rerun
        if (specArg) {
            filters.push('--spec', specArg);
        }
        return filters;
    },
    mocha: ({ specArg, payload }) => {
        const filters = [];
        if (specArg) {
            filters.push('--spec', specArg);
        }
        // For both tests and suites, use grep to filter
        if (payload.fullTitle) {
            filters.push('--mochaOpts.grep', payload.fullTitle);
        }
        return filters;
    },
    jasmine: ({ specArg, payload }) => {
        const filters = [];
        if (specArg) {
            filters.push('--spec', specArg);
        }
        // For both tests and suites, use grep to filter
        if (payload.fullTitle) {
            filters.push('--jasmineOpts.grep', payload.fullTitle);
        }
        return filters;
    }
};
const DEFAULT_FILTERS = ({ specArg }) => specArg ? ['--spec', specArg] : [];
class TestRunner {
    constructor() {
        _TestRunner_instances.add(this);
        _TestRunner_child.set(this, void 0);
        _TestRunner_lastPayload.set(this, void 0);
        _TestRunner_baseDir.set(this, process.cwd());
    }
    async run(payload) {
        if (__classPrivateFieldGet(this, _TestRunner_child, "f")) {
            throw new Error('A test run is already in progress');
        }
        const configPath = __classPrivateFieldGet(this, _TestRunner_instances, "m", _TestRunner_resolveConfigPath).call(this, payload);
        __classPrivateFieldSet(this, _TestRunner_baseDir, process.env.DEVTOOLS_RUNNER_CWD || path.dirname(configPath), "f");
        const args = [
            wdioBin,
            'run',
            configPath,
            ...__classPrivateFieldGet(this, _TestRunner_instances, "m", _TestRunner_buildFilters).call(this, payload)
        ].filter(Boolean);
        const childEnv = { ...process.env };
        if (payload.devtoolsHost && payload.devtoolsPort) {
            childEnv.DEVTOOLS_APP_HOST = payload.devtoolsHost;
            childEnv.DEVTOOLS_APP_PORT = String(payload.devtoolsPort);
            childEnv.DEVTOOLS_APP_REUSE = '1';
        }
        const child = spawn(process.execPath, args, {
            cwd: __classPrivateFieldGet(this, _TestRunner_baseDir, "f"),
            env: childEnv,
            stdio: 'inherit',
            detached: false
        });
        __classPrivateFieldSet(this, _TestRunner_child, child, "f");
        __classPrivateFieldSet(this, _TestRunner_lastPayload, payload, "f");
        child.once('close', () => {
            __classPrivateFieldSet(this, _TestRunner_child, undefined, "f");
            __classPrivateFieldSet(this, _TestRunner_lastPayload, undefined, "f");
            __classPrivateFieldSet(this, _TestRunner_baseDir, process.cwd(), "f");
        });
        await new Promise((resolve, reject) => {
            child.once('spawn', resolve);
            child.once('error', (error) => {
                __classPrivateFieldSet(this, _TestRunner_child, undefined, "f");
                __classPrivateFieldSet(this, _TestRunner_lastPayload, undefined, "f");
                __classPrivateFieldSet(this, _TestRunner_baseDir, process.cwd(), "f");
                reject(error);
            });
        });
    }
    stop() {
        if (!__classPrivateFieldGet(this, _TestRunner_child, "f") || !__classPrivateFieldGet(this, _TestRunner_child, "f").pid) {
            return;
        }
        const pid = __classPrivateFieldGet(this, _TestRunner_child, "f").pid;
        // Kill the entire process tree
        kill(pid, 'SIGTERM', (err) => {
            if (err) {
                console.error('Error stopping test run:', err);
                // Try force kill if graceful termination fails
                kill(pid, 'SIGKILL');
            }
        });
        // Clean up immediately
        __classPrivateFieldSet(this, _TestRunner_child, undefined, "f");
        __classPrivateFieldSet(this, _TestRunner_lastPayload, undefined, "f");
        __classPrivateFieldSet(this, _TestRunner_baseDir, process.cwd(), "f");
    }
}
_TestRunner_child = new WeakMap(), _TestRunner_lastPayload = new WeakMap(), _TestRunner_baseDir = new WeakMap(), _TestRunner_instances = new WeakSet(), _TestRunner_buildFilters = function _TestRunner_buildFilters(payload) {
    const framework = (payload.framework || '').toLowerCase();
    const specFile = payload.runAll
        ? undefined
        : __classPrivateFieldGet(this, _TestRunner_instances, "m", _TestRunner_normaliseSpecFile).call(this, payload);
    const specArg = specFile
        ? __classPrivateFieldGet(this, _TestRunner_instances, "m", _TestRunner_buildSpecArgument).call(this, specFile, payload)
        : undefined;
    const builderCandidate = FRAMEWORK_FILTERS[framework];
    const builder = typeof builderCandidate === 'function'
        ? builderCandidate
        : DEFAULT_FILTERS;
    return builder({ specArg, payload });
}, _TestRunner_buildSpecArgument = function _TestRunner_buildSpecArgument(specFile, payload) {
    const line = __classPrivateFieldGet(this, _TestRunner_instances, "m", _TestRunner_resolveLineNumber).call(this, payload);
    return line ? `${specFile}:${line}` : specFile;
}, _TestRunner_resolveLineNumber = function _TestRunner_resolveLineNumber(payload) {
    if (payload.lineNumber && payload.lineNumber > 0) {
        return payload.lineNumber;
    }
    const source = payload.callSource?.trim() || __classPrivateFieldGet(this, _TestRunner_lastPayload, "f")?.callSource;
    if (!source) {
        return __classPrivateFieldGet(this, _TestRunner_lastPayload, "f")?.lineNumber;
    }
    const match = /:(\d+)(?::\d+)?$/.exec(source);
    return match ? Number(match[1]) : __classPrivateFieldGet(this, _TestRunner_lastPayload, "f")?.lineNumber;
}, _TestRunner_normaliseSpecFile = function _TestRunner_normaliseSpecFile(payload) {
    const candidate = __classPrivateFieldGet(this, _TestRunner_instances, "m", _TestRunner_getSpecCandidate).call(this, payload);
    return candidate ? __classPrivateFieldGet(this, _TestRunner_instances, "m", _TestRunner_toFsPath).call(this, candidate) : undefined;
}, _TestRunner_getSpecCandidate = function _TestRunner_getSpecCandidate(payload) {
    return (payload?.specFile ||
        __classPrivateFieldGet(this, _TestRunner_instances, "m", _TestRunner_extractSpecFromCallSource).call(this, payload?.callSource) ||
        __classPrivateFieldGet(this, _TestRunner_lastPayload, "f")?.specFile);
}, _TestRunner_extractSpecFromCallSource = function _TestRunner_extractSpecFromCallSource(source) {
    if (!source) {
        return undefined;
    }
    const match = /^(.*?):\d+:\d+$/.exec(source.trim());
    return match?.[1] ?? source;
}, _TestRunner_toFsPath = function _TestRunner_toFsPath(candidate) {
    const filePath = candidate.startsWith('file://')
        ? url.fileURLToPath(candidate)
        : candidate;
    return path.isAbsolute(filePath)
        ? filePath
        : path.resolve(__classPrivateFieldGet(this, _TestRunner_baseDir, "f"), filePath);
}, _TestRunner_resolveConfigPath = function _TestRunner_resolveConfigPath(payload) {
    const specCandidate = __classPrivateFieldGet(this, _TestRunner_instances, "m", _TestRunner_getSpecCandidate).call(this, payload);
    const specDir = specCandidate
        ? path.dirname(__classPrivateFieldGet(this, _TestRunner_instances, "m", _TestRunner_toFsPath).call(this, specCandidate))
        : undefined;
    const candidates = __classPrivateFieldGet(this, _TestRunner_instances, "m", _TestRunner_dedupeCandidates).call(this, [
        payload?.configFile,
        __classPrivateFieldGet(this, _TestRunner_lastPayload, "f")?.configFile,
        process.env.DEVTOOLS_WDIO_CONFIG,
        __classPrivateFieldGet(this, _TestRunner_instances, "m", _TestRunner_findConfigFromSpec).call(this, specCandidate),
        ...__classPrivateFieldGet(this, _TestRunner_instances, "m", _TestRunner_expandDefaultConfigsFor).call(this, __classPrivateFieldGet(this, _TestRunner_baseDir, "f")),
        ...__classPrivateFieldGet(this, _TestRunner_instances, "m", _TestRunner_expandDefaultConfigsFor).call(this, path.resolve(__classPrivateFieldGet(this, _TestRunner_baseDir, "f"), 'example')),
        ...__classPrivateFieldGet(this, _TestRunner_instances, "m", _TestRunner_expandDefaultConfigsFor).call(this, specDir)
    ]);
    for (const candidate of candidates) {
        const resolved = __classPrivateFieldGet(this, _TestRunner_instances, "m", _TestRunner_toFsPath).call(this, candidate);
        if (fs.existsSync(resolved)) {
            return resolved;
        }
    }
    throw new Error(`Cannot locate WDIO config. Tried:\n${candidates
        .map((c) => ` â€¢ ${__classPrivateFieldGet(this, _TestRunner_instances, "m", _TestRunner_toFsPath).call(this, c)}`)
        .join('\n')}`);
}, _TestRunner_findConfigFromSpec = function _TestRunner_findConfigFromSpec(specFile) {
    if (!specFile) {
        return undefined;
    }
    const fsSpec = __classPrivateFieldGet(this, _TestRunner_instances, "m", _TestRunner_toFsPath).call(this, specFile);
    let dir = path.dirname(fsSpec);
    const root = path.parse(dir).root;
    while (dir && dir !== root) {
        for (const file of WDIO_CONFIG_FILENAMES) {
            const candidate = path.join(dir, file);
            if (fs.existsSync(candidate)) {
                return candidate;
            }
        }
        const parent = path.dirname(dir);
        if (parent === dir) {
            break;
        }
        dir = parent;
    }
    return undefined;
}, _TestRunner_expandDefaultConfigsFor = function _TestRunner_expandDefaultConfigsFor(baseDir) {
    if (!baseDir) {
        return [];
    }
    return WDIO_CONFIG_FILENAMES.map((file) => path.resolve(baseDir, file));
}, _TestRunner_dedupeCandidates = function _TestRunner_dedupeCandidates(values) {
    return Array.from(new Set(values.filter((value) => typeof value === 'string' && value.length > 0)));
};
function resolveWdioBin() {
    const envOverride = process.env.DEVTOOLS_WDIO_BIN;
    if (envOverride) {
        const overriddenPath = path.isAbsolute(envOverride)
            ? envOverride
            : path.resolve(process.cwd(), envOverride);
        if (!fs.existsSync(overriddenPath)) {
            throw new Error(`DEVTOOLS_WDIO_BIN "${overriddenPath}" does not exist or is not accessible`);
        }
        return overriddenPath;
    }
    try {
        const cliEntry = require.resolve('@wdio/cli');
        const candidate = path.resolve(path.dirname(cliEntry), '../bin/wdio.js');
        if (!fs.existsSync(candidate)) {
            throw new Error(`Derived WDIO bin "${candidate}" does not exist`);
        }
        return candidate;
    }
    catch (error) {
        throw new Error(`Failed to resolve WDIO binary. Provide DEVTOOLS_WDIO_BIN env var. ${error.message}`);
    }
}
export const testRunner = new TestRunner();
