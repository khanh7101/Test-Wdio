import { remote as E } from "webdriverio";
import { start as l } from "@wdio/devtools-backend";
import a from "@wdio/logger";
const T = [
  "url",
  "navigateTo",
  "elementClick"
], _ = {
  browserName: "chrome",
  "goog:chromeOptions": {
    // production:
    args: ["--window-size=1600,1200"]
    // development:
    // args: ['--window-size=1600,1200', '--auto-open-devtools-for-tabs']
  }
}, m = [
  "emit",
  "browsingContextLocateNodes",
  "browsingContextNavigate",
  "waitUntil",
  "getTitle",
  "getUrl",
  "getWindowSize",
  "setWindowSize",
  "deleteSession",
  "findElementFromShadowRoot",
  "findElementsFromShadowRoot",
  "waitForExist",
  "browsingContextGetTree",
  "scriptCallFunction",
  "getElement",
  "execute",
  "findElement",
  "getElementText",
  "getElementShadowRoot"
], w = [
  "url",
  "back",
  "forward",
  "refresh",
  "switchFrame",
  "newWindow",
  "createWindow",
  "closeWindow"
], A = /\/(test|spec|features|pageobjects|@wdio\/expect-webdriverio)\//i, P = [
  "typescript",
  "jsx",
  "decorators-legacy",
  "classProperties",
  "dynamicImport"
], R = ["it", "test", "specify", "fit", "xit"], u = ["describe", "context", "suite"], f = [
  "Given",
  "When",
  "Then",
  "And",
  "But",
  "defineStep"
], g = /\.(?:steps?)\.[cm]?[jt]sx?$/i, N = /(?:^|\/)(?:step[-_]?definitions|steps)\/.+\.[cm]?[jt]sx?$/i, C = /\.(?:test|spec)\.[cm]?[jt]sx?$/i, v = /\.feature$/i, F = /\.(?:[cm]?js|[cm]?ts)x?$/, L = /^\s*(Feature|Scenario(?: Outline)?):\s*(.+)\s*$/i, b = /\b(Given|When|Then|And|But)\s*\(\s*(\/(?:\\.|[^/\\])+\/[gimsuy]*)/, I = /\b(Given|When|Then|And|But)\s*\(\s*(['`])([^'`\\]*(?:\\.[^'`\\]*)*)\2/, O = [
  "step-definitions",
  "step_definitions",
  "steps"
], D = 6, x = 5, i = a("@wdio/devtools-service:Launcher");
class y {
  #t;
  #e;
  constructor(t) {
    this.#t = t;
  }
  async onPrepare(t, s) {
    try {
      const e = process.env.DEVTOOLS_APP_PORT, r = process.env.DEVTOOLS_APP_HOST || this.#t.hostname || "localhost";
      if (process.env.DEVTOOLS_APP_REUSE === "1" && e) {
        i.info(
          `Reusing existing DevTools app at http://${r}:${e}`
        ), this.#s(s, {
          port: Number(e),
          hostname: r
        });
        return;
      }
      const { server: c } = await l({
        port: this.#t.port,
        hostname: this.#t.hostname
      }), n = c.address(), o = n && typeof n == "object" ? n.port : void 0;
      if (!o)
        return console.log(`Failed to start server on port ${o}`);
      this.#s(s, {
        port: o,
        hostname: this.#t.hostname || "localhost"
      }), this.#e = await E({
        automationProtocol: "devtools",
        capabilities: {
          ..._,
          ...this.#t.devtoolsCapabilities
        }
      }), await this.#e.url(`http://localhost:${o}`);
    } catch (e) {
      console.error(e);
    }
  }
  async onComplete() {
    if (this.#e) {
      for (a.setLevel("devtools", "warn"), i.info("Please close the browser window to finish..."); ; )
        try {
          await this.#e.getTitle(), await new Promise((t) => setTimeout(t, 1e3));
        } catch {
          i.info("Browser window closed, stopping DevTools app");
          break;
        }
      try {
        await this.#e.deleteSession();
      } catch (t) {
        i.warn("Session already closed or could not be deleted:", t.message);
      }
    }
  }
  #s(t, s) {
    if (Array.isArray(t))
      for (const e of t)
        e["wdio:devtoolsOptions"] = {
          port: s.port,
          hostname: s.hostname || "localhost"
        };
  }
}
export {
  w as C,
  y as D,
  v as F,
  m as I,
  T as P,
  u as S,
  R as T,
  L as a,
  P as b,
  D as c,
  O as d,
  f as e,
  g as f,
  N as g,
  C as h,
  x as i,
  F as j,
  b as k,
  I as l,
  A as m
};
